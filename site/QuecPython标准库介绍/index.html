<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>QuecPython标准库介绍 - QuecPython</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "QuecPython\u6807\u51c6\u5e93\u4ecb\u7ecd";
    var mkdocs_page_input_path = "QuecPython\u6807\u51c6\u5e93\u4ecb\u7ecd.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> QuecPython</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">QuecPython理论学习</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/">QuecPython开发准备</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">QuecPython快速入门</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">QuecPython标准库介绍</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#uos-">uos - 基本系统服务</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gc-">gc - 内存碎片回收</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ubinascii-ascii">ubinascii - 二进制与ASCII转换</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ucollections-">ucollections - 集合和容器类型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#urandom-">urandom - 生成随机数</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#math-">math - 数学运算</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#usocket-socket">usocket - socket模块</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#uio-">uio - 输入输出流</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ustruct-">ustruct - 打包和解压原始数据类型</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#ujson-json">ujson - JSON编码和解码</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#utime-">utime - 与时间相关功能</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sys-">sys - 系统相关功能</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#uzlib-zlib">uzlib - zlib解压缩</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_thread-">_thread - 多线程</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#uhashlib-">uhashlib - 哈希算法</a>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E5%B9%B3%E5%8F%B0%E6%80%A7%E6%8E%A5%E5%8F%A3/">QuecPython平台性接口</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E9%A9%B1%E5%8A%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/">QuecPython驱动子系统</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E6%97%A0%E7%BA%BF%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/">QuecPython无线联网开发</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/">QuecPython网络应用开发</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E4%BA%91%E6%9C%8D%E5%8A%A1/">QuecPython云服务</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E5%B0%8F%E5%AE%9E%E9%AA%8C/">QuecPython小实验</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/">QuecPython应用编程框架</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%20Solution%E6%96%B9%E6%A1%88%E5%BC%80%E5%8F%91/">QuecPython Solution方案开发</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%20FAQ%26DEBUG/">QuecPython FAQ&DEBUG</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../QuecPython%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E5%8F%8A%E9%87%8F%E4%BA%A7/">QuecPython产品开发及量产</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">QuecPython</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>QuecPython标准库介绍</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="quecpython">QuecPython标准库介绍</h1>
<p>QuecPython标准库</p>
<h4 id="uos-">uos - 基本系统服务</h4>
<p>uos模块包含文件系统访问和挂载构建，该模块实现了CPython模块相应模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/os.html#module-os">os</a></p>
<blockquote>
<p><strong>uos.remove(path)</strong> </p>
</blockquote>
<p>删除文件。path表示文件名。</p>
<blockquote>
<p><strong>uos.chdir(path)</strong></p>
</blockquote>
<p>改变当前目录。path表示目录名。</p>
<blockquote>
<p><strong>uos.getcwd()</strong></p>
</blockquote>
<p>获取当前路径。</p>
<blockquote>
<p><strong>uos.listdir( [dir] )</strong></p>
</blockquote>
<p>没有参数列出当前目录文件，否则列出给定目录的文件。dir为可选参数，表示目录名，默认为 ‘/’ 目录。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; uos.listdir()
[‘file1’, ‘read.txt’, ‘demo.py’]
</code></pre>
<blockquote>
<p><strong>uos.mkdir(path)</strong></p>
</blockquote>
<p>创建一个新的目录。path表示准备创建的目录名。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; uos.mkdir('testdir')
&gt;&gt;&gt; uos.listdir()
[‘file1’, ‘read.txt’, ‘demo.py’, 'testdir']
</code></pre>
<blockquote>
<p><strong>uos.rename(old_path, new_path)</strong></p>
</blockquote>
<p>重命名文件。old_path表示旧文件或目录名，new_path表示新文件或目录名。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; uos.rename('testdir', 'testdir1')
</code></pre>
<blockquote>
<p><strong>uos.rmdir(path)</strong></p>
</blockquote>
<p>删除指定目录。path表示目录名。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; uos.rmdir('testdir')
&gt;&gt;&gt; uos.listdir()
[‘file1’, ‘read.txt’, ‘demo.py’]
</code></pre>
<blockquote>
<p><strong>uos.ilistdir( [dir] )</strong></p>
</blockquote>
<p>该函数返回一个迭代器，该迭代器会生成所列出条目对应的3元组。dir为可选参数，表示目录名，没有参数时，默认列出当前目录，有参数时，则列出dir参数指定的目录。元组的形式为 <code>(name, type, inode[, size])</code>:</p>
<ul>
<li>name 是条目的名称，字符串类型，如果dir是字节对象，则名称为字节;</li>
<li>type 是条目的类型，整型数，0x4000表示目录，0x8000表示常规文件；</li>
<li>是一个与文件的索引节点相对应的整数，对于没有这种概念的文件系统来说，可能为0；</li>
<li>一些平台可能会返回一个4元组，其中包含条目的size。对于文件条目，size表示文件大小的整数，如果未知，则为-1。对于目录项，其含义目前尚未定义。</li>
</ul>
<blockquote>
<p><strong>uos.stat(path)</strong></p>
</blockquote>
<p>获取文件或目录的状态。path表示文件或目录名。返回值是一个元组，返回值形式为：</p>
<p><code>(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)</code></p>
<ul>
<li><code>mode</code> – inode保护模式</li>
<li><code>ino</code> – inode节点号</li>
<li><code>dev</code>  – inode驻留的设备</li>
<li><code>nlink</code>  – inode的链接数</li>
<li><code>uid</code> – 所有者的用户ID</li>
<li><code>gid</code>  – 所有者的组ID</li>
<li><code>size</code>  – 文件大小，单位字节</li>
<li><code>atime</code>  – 上次访问的时间</li>
<li><code>mtime</code>  – 最后一次修改的时间</li>
<li><code>ctime</code>  – 操作系统报告的“ctime”，在某些系统上是最新的元数据更改的时间，在其它系统上是创建时间，详细信息参见平台文档</li>
</ul>
<blockquote>
<p><strong>uos.statvfs(path)</strong></p>
</blockquote>
<p>获取文件系统状态信息。path表示文件或目录名。返回一个包含文件系统信息的元组：</p>
<p><code>(f_bsize, f_frsize, f_blocks, f_bfree, f_bavail, f_files, f_ffree, f_favail, f_flag, f_namemax)</code></p>
<ul>
<li><code>f_bsize</code> – 文件系统块大小，单位字节</li>
<li><code>f_frsize</code> – 分栈大小，单位字节</li>
<li><code>f_blocks</code> – 文件系统数据块总数</li>
<li><code>f_bfree</code> – 可用块数</li>
<li><code>f_bavai</code> – 非超级用户可获取的块数</li>
<li><code>f_files</code>  – 文件结点总数</li>
<li><code>f_ffree</code> – 可用文件结点数</li>
<li><code>f_favail</code> – 超级用户的可用文件结点数</li>
<li><code>f_flag</code> – 挂载标记</li>
<li><code>f_namemax</code> – 最大文件长度，单位字节</li>
</ul>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import uos
&gt;&gt;&gt; res = uos.statvfs(&quot;main.py&quot;)
&gt;&gt;&gt; print(res)
(4096, 4096, 256, 249, 249, 0, 0, 0, 0, 255)
</code></pre>
<blockquote>
<p><strong>uos.uname()</strong></p>
</blockquote>
<p>获取关于底层信息或其操作系统的信息。返回一个元组，形式为：</p>
<p><code>(sysname, nodename, release, version, machine)</code></p>
<ul>
<li>
<p><code>sysname</code> – 底层系统的名称，string类型</p>
</li>
<li>
<p><code>nodename</code> – 网络名称(可以与 sysname 相同) ，string类型</p>
</li>
<li>
<p><code>release</code> – 底层系统的版本，string类型</p>
</li>
<li>
<p><code>version</code> – MicroPython版本和构建日期，string类型</p>
</li>
<li>
<p><code>machine</code> – 底层硬件(如主板、CPU)的标识符，string类型</p>
</li>
</ul>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import uos
&gt;&gt;&gt; uos.uname()
(sysname='EC100Y', nodename='EC100Y', release='1.12.0', version='v1.12 on 2020-06-23', machine='EC100Y with QUECTEL')
</code></pre>
<blockquote>
<p><strong>uos.urandom(n)</strong></p>
</blockquote>
<p>返回具有<em>n个</em>随机字节的bytes对象，只要有可能，它就会由硬件随机数生成器生成。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import uos
&gt;&gt;&gt; uos.urandom(5)
b'\xb3\xc9Y\x1b\xe9'
</code></pre>
<h4 id="gc-">gc - 内存碎片回收</h4>
<p>gc 模块实现内存垃圾回收机制，该模块实现了CPython模块相应模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/gc.html#module-gc">gc</a></p>
<blockquote>
<p><strong>gc.enable()</strong></p>
</blockquote>
<p>启用自动回收内存碎片机制。</p>
<blockquote>
<p><strong>gc.disable()</strong></p>
</blockquote>
<p>禁用自动回收机制。</p>
<blockquote>
<p><strong>gc.collect()</strong></p>
</blockquote>
<p>回收内存碎片。</p>
<blockquote>
<p><strong>gc.mem_alloc()</strong></p>
</blockquote>
<p>返回分配的堆RAM的字节数。此功能是MicroPython扩展。</p>
<blockquote>
<p><strong>gc.mem_free()</strong></p>
</blockquote>
<p>返回可用堆RAM的字节数，如果此数量未知，则返回-1。此功能是MicroPython扩展。</p>
<h4 id="ubinascii-ascii">ubinascii - 二进制与ASCII转换</h4>
<p>ubinascii 模块实现了二进制数据与各种ASCII编码之间的转换(双向)，该模块实现了CPython模块相应模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/binascii.html#module-binascii">binascii</a></p>
<blockquote>
<p><strong>ubinascii.a2b_base64(data)</strong></p>
</blockquote>
<p>解码base64编码的数据，会自动忽略输入中的无效字符，返回 bytes 对象。</p>
<blockquote>
<p>ubinascii.b2a_base64(data)</p>
</blockquote>
<p>以base64格式编码二进制数据，返回编码数据。后面跟换行符，作为 bytes 对象。</p>
<blockquote>
<p><strong>ubinascii.hexlify(data, [sep])</strong></p>
</blockquote>
<p>将二进制数据转换为十六进制字符串表示。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ubinascii
# 没有sep参数
&gt;&gt;&gt; ubinascii.hexlify('\x11\x22123')
b'1122313233'
&gt;&gt;&gt; ubinascii.hexlify('abcdfg')
b'616263646667'
# 指定了第二个参数sep，它将用于分隔两个十六进制数
&gt;&gt;&gt; ubinascii.hexlify('\x11\x22123', ' ')
b'11 22 31 32 33'
&gt;&gt;&gt; ubinascii.hexlify('\x11\x22123', ',')
b'11,22,31,32,33'
</code></pre>
<blockquote>
<p><strong>ubinascii.unhexlify(data)</strong></p>
</blockquote>
<p>将十六进制形式的字符串转换成二进制形式的字符串表示。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ubinascii
&gt;&gt;&gt; ubinascii.unhexlify('313222')
b'12&quot;'
</code></pre>
<h4 id="ucollections-">ucollections - 集合和容器类型</h4>
<p>ucollections 模块用于创建一个新的容器类型，用于保存各种对象。该模块实现了CPython模块相应模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/collections.html#module-collections">collections</a></p>
<blockquote>
<p><strong>mytuple = ucollections.namedtuple(name, fields)</strong></p>
</blockquote>
<p>创建一个具有特定名称和一组字段的新namedtuple容器类型，namedtuple是元组的子类，允许通过索引来访问它的字段。</p>
<p>参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>str</td>
<td>新创建容器的类型名称</td>
</tr>
<tr>
<td>fields</td>
<td>tuple</td>
<td>新创建容器类型包含子类型的字段</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ucollections
&gt;&gt;&gt; mytuple = ucollections.namedtuple(&quot;mytuple&quot;, (&quot;id&quot;, &quot;name&quot;))
&gt;&gt;&gt; t1 = mytuple(1, &quot;foo&quot;)
&gt;&gt;&gt; t2 = mytuple(2, &quot;bar&quot;)
&gt;&gt;&gt; print(t1.name)
foo
</code></pre>
<blockquote>
<p><strong>dq = ucollections.deque(iterable, maxlen, flag)</strong></p>
</blockquote>
<p>创建deque双向队列</p>
<ul>
<li>参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterable</td>
<td>tuple</td>
<td>iterable必须是空元组</td>
</tr>
<tr>
<td>maxlen</td>
<td>int</td>
<td>指定maxlen并将双端队列限制为此最大长度</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>可选参数；0(默认)：不检查队列是否溢出，达到最大长度时继续append会丢弃之前的值  ，1：当队列达到最大设定长度会抛出IndexError: full</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>deque对象</p>
<p><strong>deque对象方法</strong></p>
<blockquote>
<p>​ <strong>dq.append(data)</strong></p>
</blockquote>
<p>往队列中插入值。</p>
<ul>
<li>参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>基本数据类型</td>
<td>需要添加到队列的数值</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>无</p>
<blockquote>
<p>​ <strong>dq.popleft()</strong></p>
</blockquote>
<p>从deque的左侧移除并返回移除的数据。如果没有deque为空，会引起索引错误</p>
<ul>
<li>参数</li>
</ul>
<p>无</p>
<ul>
<li>返回值</li>
</ul>
<p>返回pop出的值</p>
<p><strong>使用示例</strong></p>
<pre><code class="language-python">from ucollections import deque

dq = deque((),5)
dq.append(1)
dq.append([&quot;a&quot;])
dq.append(&quot;a&quot;)

dq.popleft()  # 1
dq.popleft()  # [&quot;a&quot;]
dq.popleft()  # a
</code></pre>
<h4 id="urandom-">urandom - 生成随机数</h4>
<p>urandom 模块提供了生成随机数的工具。</p>
<blockquote>
<p><strong>urandom.choice(obj)</strong></p>
</blockquote>
<p>随机生成对象 obj 中的元素，obj 类型 string。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.choice(&quot;QuecPython&quot;)
't'
</code></pre>
<blockquote>
<p><strong>urandom.getrandbits(k)</strong></p>
</blockquote>
<p>随机产生一个k比特长的随机整数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.getrandbits(1)  #1位二进制位，范围为0~1（十进制：0~1）
1
&gt;&gt;&gt; urandom.getrandbits(1)
0
&gt;&gt;&gt; urandom.getrandbits(8)  #8位二进制位，范围为0000 0000~1111 11111（十进制：0~255）
224
</code></pre>
<blockquote>
<p><strong>urandom.randint(start, end)</strong></p>
</blockquote>
<p>随机生成一个 start 到 end 之间的整数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.randint(1, 4)
4
&gt;&gt;&gt; urandom.randint(1, 4)
2
</code></pre>
<blockquote>
<p><strong>urandom.random()</strong></p>
</blockquote>
<p>随机生成一个 0 到 1 之间的浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.random()
0.8465231
</code></pre>
<blockquote>
<p><strong>urandom.randrange(start, end, step)</strong></p>
</blockquote>
<p>随机生成 start 到 end 间并且递增为 step 的正整数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.randrange(0, 8, 2)
0
&gt;&gt;&gt; urandom.randrange(0, 8, 2)
6
</code></pre>
<blockquote>
<p><strong>urandom.seed(sed)</strong></p>
</blockquote>
<p>指定随机数种子，通常和其它随机数生成函数搭配使用。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.seed(20)  #指定随机数种子
&gt;&gt;&gt; for i in range(0, 15): #生成0~15范围内的随机序列
...     print(urandom.randint(1, 10))
...     
8
10
9
10
2
1
9
3
2
2
6
1
10
9
6
</code></pre>
<blockquote>
<p><strong>urandom.uniform(start, end)</strong></p>
</blockquote>
<p>随机生成 start 到 end 范围内的浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import urandom
&gt;&gt;&gt; urandom.uniform(3, 5)
3.219261
&gt;&gt;&gt; urandom.uniform(3, 5)
4.00403
</code></pre>
<h4 id="math-">math - 数学运算</h4>
<p>math 模块提供数学运算函数。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/math.html#module-math">math</a></p>
<blockquote>
<p><strong>math.pow(x, y)</strong></p>
</blockquote>
<p>返回x的y次方，返回值是浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.pow(2, 3)
8.0
</code></pre>
<blockquote>
<p><strong>math.acos(x)</strong></p>
</blockquote>
<p>返回x的反余弦弧度值，返回值为浮点数。x是-1~1之间的数，包括-1和1，如果小于-1或者大于1，会产生错误。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.acos(0.6)
0.9272952
</code></pre>
<blockquote>
<p><strong>math.asin(x)</strong></p>
</blockquote>
<p>返回x的反正弦弧度值，返回值为浮点数。x是-1~1之间的数，包括-1和1，如果小于-1或者大于1，会产生错误。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.asin(-1)
-1.570796
</code></pre>
<blockquote>
<p><strong>math.atan(x)</strong></p>
</blockquote>
<p>返回x的反正切弧度值，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.atan(-8)
-1.446441
&gt;&gt;&gt; math.atan(6.4)
1.4158
</code></pre>
<blockquote>
<p><strong>math.atan2(x, y)</strong></p>
</blockquote>
<p>返回给定的 X 及 Y 坐标值的反正切值，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.atan2(-0.50,0.48)
-0.8058035
&gt;&gt;&gt; math.atan2(7, 9)
0.6610432
</code></pre>
<blockquote>
<p><strong>math.ceil(x)</strong></p>
</blockquote>
<p>返回数字的上入整数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.ceil(4.1)
5
</code></pre>
<blockquote>
<p><strong>math.copysign(x, y)</strong></p>
</blockquote>
<p>把y的正负号加到x前面，可以使用0，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.copysign(5, 0)
5.0
&gt;&gt;&gt; math.copysign(5, -4)
-5.0
&gt;&gt;&gt; math.copysign(5, 9)
5.0
</code></pre>
<blockquote>
<p><strong>math.cos(x)</strong></p>
</blockquote>
<p>返回x的弧度的余弦值，范围再-1~1之间，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.cos(3)
-0.9899925
</code></pre>
<blockquote>
<p><strong>math.degrees(x)</strong></p>
</blockquote>
<p>将弧度转换为角度，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.degrees(5)
286.4789
&gt;&gt;&gt; math.degrees(math.pi/2)
90.0
</code></pre>
<blockquote>
<p><strong>math.e</strong></p>
</blockquote>
<p>数学常量 <code>e</code>，<code>e</code>即自然常数。</p>
<blockquote>
<p><strong>math.exp(x)</strong></p>
</blockquote>
<p>返回e的x次幂，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.exp(1)
2.718282
&gt;&gt;&gt; print(math.e)
2.718282
</code></pre>
<blockquote>
<p><strong>math.fabs(x)</strong></p>
</blockquote>
<p>返回数字的绝对值，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.fabs(-3.88)
3.88
</code></pre>
<blockquote>
<p><strong>math.floor(x)</strong></p>
</blockquote>
<p>返回数字的下舍整数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.floor(8.7)
8
&gt;&gt;&gt; math.floor(9)
9
&gt;&gt;&gt; math.floor(-7.6)
-8
</code></pre>
<blockquote>
<p><strong>math.fmod(x, y)</strong></p>
</blockquote>
<p>返回x/y的余数，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.fmod(15, 4)
3.0
&gt;&gt;&gt; math.fmod(15, 3)
0.0
</code></pre>
<blockquote>
<p><strong>math.modf(x)</strong></p>
</blockquote>
<p>返回由x的小数部分和整数部分组成的元组。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.modf(17.592)
(0.5919991, 17.0)
</code></pre>
<blockquote>
<p><strong>math.frexp(x)</strong></p>
</blockquote>
<p>返回一个元组(m,e),其计算方式为：x分别除0.5和1,得到一个值的范围，2e的值在这个范围内，e取符合要求的最大整数值,然后x/(2e)，得到m的值。如果x等于0，则m和e的值都为0，m的绝对值的范围为(0.5,1)之间，不包括0.5和1。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.frexp(52)
(0.8125, 6)
</code></pre>
<blockquote>
<p><strong>math.isfinite(x)</strong></p>
</blockquote>
<p>判断 x 是否为有限数，是则返回True，否则返回False。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.isfinite(8)
True
</code></pre>
<blockquote>
<p><strong>math.isinf(x)</strong></p>
</blockquote>
<p>如果x是正无穷大或负无穷大，则返回True,否则返回False。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.isinf(123)
False
</code></pre>
<blockquote>
<p><strong>math.isnan(x)</strong></p>
</blockquote>
<p>如果x不是数字True,否则返回False。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.isnan(23)
False
</code></pre>
<blockquote>
<p><strong>math.ldexp(x, exp)</strong></p>
</blockquote>
<p>返回x<em>(2</em>*i)的值。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.ldexp(2, 1)
4.0
</code></pre>
<blockquote>
<p><strong>math.log(x)</strong></p>
</blockquote>
<p>返回x的自然对数，x &gt; 0，小于0会报错。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.log(2)
0.6931472
</code></pre>
<blockquote>
<p><strong>math.pi</strong></p>
</blockquote>
<p>数学常量 pi（圆周率，一般以π来表示）。</p>
<blockquote>
<p><strong>math.radians(x)</strong></p>
</blockquote>
<p>将角度转换为弧度，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.radians(90)
1.570796
</code></pre>
<blockquote>
<p><strong>math.sin(x)</strong></p>
</blockquote>
<p>返回x弧度的正弦值，数值在 -1 到 1 之间。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.sin(-18)
0.7509873
&gt;&gt;&gt; math.sin(50)
-0.2623749
</code></pre>
<blockquote>
<p><strong>math.sqrt(x)</strong></p>
</blockquote>
<p>返回数字x的平方根，返回值为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.sqrt(4)
2.0
&gt;&gt;&gt; math.sqrt(7)
2.645751
</code></pre>
<blockquote>
<p><strong>math.tan(x)</strong></p>
</blockquote>
<p>返回 x 弧度的正切值，数值在 -1 到 1 之间，为浮点数。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.tan(9)
-0.4523157
</code></pre>
<blockquote>
<p><strong>math.trunc(x)</strong></p>
</blockquote>
<p>返回x的整数部分。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.trunc(7.123)
7
</code></pre>
<h4 id="usocket-socket">usocket - socket模块</h4>
<p>usocket 模块提供对BSD套接字接口的访问。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/socket.html#module-socket">socket</a></p>
<blockquote>
<p><strong>usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP)</strong></p>
</blockquote>
<p>根据给定的地址族、套接字类型以及协议类型参数，创建一个新的套接字。注意，在大多数情况下不需要指定<em>proto</em>，也不建议这样做，因为某些MicroPython端口可能会省略 <code>IPPROTO_*</code>常量。</p>
<p><strong>常量说明</strong></p>
<p>af - 地址族</p>
<ul>
<li>
<p>usocket.AF_INET ：IPV4</p>
</li>
<li>
<p>usocket.AF_INET6 ：IPV6</p>
</li>
</ul>
<p>type - socket类型</p>
<ul>
<li>
<p>usocket.SOCK_STREAM ：对应TCP的流式套接字</p>
</li>
<li>
<p>usocket.SOCK_DGRAM ：对应UDP的数据包套接字</p>
</li>
<li>
<p>usocket.SOCK_RAW ：原始套接字</p>
</li>
</ul>
<p>proto - 协议号</p>
<ul>
<li>
<p>usocket.IPPROTO_TCP</p>
</li>
<li>
<p>usocket.IPPROTO_UDP</p>
</li>
</ul>
<p>其他</p>
<ul>
<li>
<p>usocket.SOL_SOCKET - 套接字选项级别，</p>
</li>
<li>
<p>usocket.SO_REUSEADDR - 允许绑定地址快速重用</p>
</li>
</ul>
<p>示例：</p>
<pre><code>import usocket
# 创建基于TCP的流式套接字
socket = usocket.socket(usocket.AF_INET, usocket.SOCK_STREAM)
# 创建基于UDP的数据报套接字
socket = usocket.socket(usocket.AF_INET, usocket.SOCK_DGRAM)
</code></pre>
<blockquote>
<p><strong>usocket.getaddrinfo(host, port)</strong></p>
</blockquote>
<p>将主机域名（host）和端口（port）转换为用于创建套接字的5元组序列，元组结构如下：</p>
<p><code>(family, type, proto, canonname, sockaddr)</code></p>
<p><strong>socket类的方法</strong></p>
<blockquote>
<p><strong>socket.bind(address)</strong></p>
</blockquote>
<p>绑定地址address。在此之前，socket必须没有绑定过。</p>
<ul>
<li><code>address</code> ：由地址端口号组成的列表或者元组</li>
</ul>
<p>示例：</p>
<pre><code>addr = ('127.0.0.1', 6000)
socket.bind(addr)
</code></pre>
<blockquote>
<p><strong>socket.listen(backlog)</strong></p>
</blockquote>
<p>允许服务端接受连接，可指定最大连接数。</p>
<ul>
<li><code>backlog</code> ：接受套接字的最大个数，至少为0。</li>
</ul>
<blockquote>
<p><strong>socket.accept()</strong></p>
</blockquote>
<p>接受连接请求，返回元组，包含新的套接字和客户端地址，形式为：<code>(conn, address)</code></p>
<ul>
<li>
<p><code>conn</code> ：新的套接字对象，可以用来发送和接收数据</p>
</li>
<li>
<p><code>address</code> ：连接到服务器的客户端地址</p>
</li>
</ul>
<blockquote>
<p><strong>socket.connect(address)</strong></p>
</blockquote>
<p>连接到指定地址address的服务器。</p>
<ul>
<li><code>address</code> ：包含地址和端口号的元组或列表</li>
</ul>
<blockquote>
<p><strong>socket.read( [ size ] )</strong></p>
</blockquote>
<p>从套接字中读取size字节数据，返回一个字节对象。如果没有指定size，则会从套接字读取所有可读数据，直到读取到数据结束，此时作用和 <code>socket.readall()</code> 相同。</p>
<blockquote>
<p><strong>socket.readinto(buf, [ , nbytes ])</strong></p>
</blockquote>
<p>将字节读取到缓冲区buf中。如果指定了nbytes，则最多读取nbytes数量的字节；如果没有指定nbytes，则最多读取len(buf)字节。返回值是实际读取的字节数。</p>
<blockquote>
<p><strong>socket.readline()</strong></p>
</blockquote>
<p>按行读取数据，遇到换行符结束，返回读取的数据行。</p>
<blockquote>
<p><strong>socket.write(buf)</strong></p>
</blockquote>
<p>写入缓冲区的数据，buf为待写入的数据，返回实际写入的字节数。</p>
<blockquote>
<p><strong>socket.send(bytes)</strong></p>
</blockquote>
<p>发送数据，返回实际发送的字节数。</p>
<ul>
<li><code>bytes</code> ：bytes型数据</li>
</ul>
<blockquote>
<p><strong>socket.sendall(bytes)</strong></p>
</blockquote>
<p>将所有数据都发送到套接字。与<code>send()</code>方法不同的是，此方法将尝试通过依次逐块发送数据来发送所有数据。</p>
<p>注意：该方法再非阻塞套接字上的行为是不确定的，建议再MicroPython中，使用 <code>write()</code> 方法，该方法具有相同的“禁止短写”策略来阻塞套接字，并且将返回在非阻塞套接字上发送的字节数。</p>
<ul>
<li><code>bytes</code> ：bytes型数据</li>
</ul>
<blockquote>
<p><strong>socket.sendto(bytes, address)</strong></p>
</blockquote>
<p>将数据发送到套接字。该套接字不应连接到远程套接字，因为目标套接字是由<em>address</em>指定的。</p>
<ul>
<li>
<p><code>bytes</code> ：bytes型数据</p>
</li>
<li>
<p><code>address</code> ：包含地址和端口号的元组或列表</p>
</li>
</ul>
<blockquote>
<p><strong>socket.recv(bufsize)</strong></p>
</blockquote>
<p>从套接字接收数据。返回值是一个字节对象，表示接收到的数据。一次接收的最大数据量由bufsize指定。</p>
<ul>
<li><code>bufsize</code> ：一次接收的最大数据量</li>
</ul>
<blockquote>
<p><strong>socket.close()</strong></p>
</blockquote>
<p>将套接字标记为关闭并释放所有资源。</p>
<blockquote>
<p><strong>socket.recvfrom(bufsize)</strong></p>
</blockquote>
<p>从套接字接收数据。返回一个元组，包含字节对象和地址。</p>
<p>返回值形式为：<code>(bytes, address)</code></p>
<ul>
<li>
<p>bytes ：接收数据的字节对象</p>
</li>
<li>
<p>address ：发送数据的套接字的地址</p>
</li>
</ul>
<blockquote>
<p><strong>socket.setsockopt(level, optname, value)</strong></p>
</blockquote>
<p>设置套接字选项的值。</p>
<ul>
<li>
<p><code>level</code> ：套接字选项级别</p>
</li>
<li>
<p><code>optname</code> ：socket选项</p>
</li>
<li>
<p><code>value</code> ：既可以是一个整数，也可以是一个表示缓冲区的bytes类对象</p>
</li>
</ul>
<p>示例：</p>
<pre><code>socket.setsockopt(usocket.SOL_SOCKET, usocket.SO_REUSEADDR, 1)
</code></pre>
<blockquote>
<p><strong>socket.setblocking(flag)</strong></p>
</blockquote>
<p>设置套接字为阻塞模式或者非阻塞模式。如果标志为false，则将套接字设置为非阻塞，否则设置为阻塞模式。</p>
<p>该方法是某些 <code>settimeout()</code> 调用的简写：</p>
<p><code>socket.setblocking(True)</code> 相当于 <code>socket.settimeout(None)</code></p>
<p><code>socket.setblocking(False)</code> 相当于 <code>socket.settimeout(0)</code></p>
<blockquote>
<p><strong>socket.settimeout(value)</strong></p>
</blockquote>
<p>设置套接字的超时时间，单位秒。</p>
<ul>
<li><code>value</code> ：可以是表示秒的非负浮点数，也可以是None。如果给出一个非零值，则<a href="http://docs.micropython.org/en/latest/library/builtins.html#OSError"><code>OSError</code></a>在该操作完成之前已超过超时时间值，则随后的套接字操作将引发异常。如果给定零，则将套接字置于非阻塞模式。如果未指定，则套接字将处于阻塞模式。</li>
</ul>
<blockquote>
<p><strong>socket.makefile(mode='rb')</strong></p>
</blockquote>
<p>返回与套接字关联的文件对象，返回值类型与指定的参数有关。仅支持二进制模式 (rb和wb)。</p>
<p><strong>socket通信示例</strong>：</p>
<pre><code># 客户端示例
import usocket
client = usocket.socket(usocket.AF_INET, usocket.SOCK_STREAM)
sockaddr = usocket.getaddrinfo('www.tongxinmao.com',80)[0][-1]
client.connect(sockaddr)
while True:
    re_data = input()
    client.send(re_data.encode(&quot;utf8&quot;))
    data = client.recv(1024)
    print(data.decode(&quot;utf8&quot;))

</code></pre>
<h4 id="uio-">uio - 输入输出流</h4>
<p>uio 模块包含其他类型的stream（类文件）对象和辅助函数。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/io.html#module-io">io</a></p>
<blockquote>
<p><strong>fd = uio.open(name, mode=’r’, **kwarg)</strong></p>
</blockquote>
<p>打开文件，内置<code>open()</code>函数是该函数的别名。</p>
<ul>
<li>
<p><code>name</code> ：文件名</p>
</li>
<li>
<p><code>mode</code> ：打开模式</p>
</li>
<li>
<p>r  只读模式打开文件</p>
</li>
<li>w  写入模式打开文件，每次写入会覆盖上次写入数据</li>
<li>
<p>a  只写追加模式打开文件，可连续写入文件数据而不是覆盖数据</p>
</li>
<li>
<p><code>**kwarg</code>：可变长参数列表</p>
</li>
</ul>
<blockquote>
<p><strong>fd.close()</strong></p>
</blockquote>
<p>关闭打开的文件。</p>
<h4 id="ustruct-">ustruct - 打包和解压原始数据类型</h4>
<p>该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/struct.html#module-struct">struct</a></p>
<p><strong>字节顺序，大小和对齐方式</strong></p>
<p>默认情况下，C类型以机器的本机格式和字节顺序表示，并在必要时通过跳过填充字节来正确对齐（根据C编译器使用的规则）。根据下表，格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式：</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Byte order</th>
<th>Size</th>
<th>Alignment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>native</td>
<td>native</td>
<td>native</td>
</tr>
<tr>
<td><code>=</code></td>
<td>native</td>
<td>standard</td>
<td>none</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>little-endian</td>
<td>standard</td>
<td>none</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>big-endian</td>
<td>standard</td>
<td>none</td>
</tr>
<tr>
<td><code>!</code></td>
<td>network (= big-endian)</td>
<td>standard</td>
<td>none</td>
</tr>
</tbody>
</table>
<p><strong>格式化字符表</strong></p>
<table>
<thead>
<tr>
<th>Format</th>
<th>C Type</th>
<th>Python type</th>
<th>Standard size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x</code></td>
<td>pad byte</td>
<td>no value</td>
<td></td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>char</code></td>
<td>bytes of length 1</td>
<td>1</td>
</tr>
<tr>
<td><code>b</code></td>
<td><code>signed char</code></td>
<td>integer</td>
<td>1</td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>unsigned char</code></td>
<td>integer</td>
<td>1</td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>_Bool</code></td>
<td>bool</td>
<td>1</td>
</tr>
<tr>
<td><code>h</code></td>
<td><code>short</code></td>
<td>integer</td>
<td>2</td>
</tr>
<tr>
<td><code>H</code></td>
<td><code>unsigned short</code></td>
<td>integer</td>
<td>2</td>
</tr>
<tr>
<td><code>i</code></td>
<td><code>int</code></td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td><code>I</code></td>
<td><code>unsigned int</code></td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>long</code></td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>unsigned long</code></td>
<td>integer</td>
<td>4</td>
</tr>
<tr>
<td><code>q</code></td>
<td><code>long long</code></td>
<td>integer</td>
<td>8</td>
</tr>
<tr>
<td><code>Q</code></td>
<td><code>unsigned long long</code></td>
<td>integer</td>
<td>8</td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>ssize_t</code></td>
<td>integer</td>
<td></td>
</tr>
<tr>
<td><code>N</code></td>
<td><code>size_t</code></td>
<td>integer</td>
<td></td>
</tr>
<tr>
<td><code>f</code></td>
<td><code>float</code></td>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td><code>d</code></td>
<td><code>double</code></td>
<td>float</td>
<td>8</td>
</tr>
<tr>
<td><code>s</code></td>
<td><code>char[]</code></td>
<td>bytes</td>
<td></td>
</tr>
<tr>
<td><code>p</code></td>
<td><code>char[]</code></td>
<td>bytes</td>
<td></td>
</tr>
<tr>
<td><code>P</code></td>
<td><code>void *</code></td>
<td>integer</td>
<td></td>
</tr>
</tbody>
</table>
<p>默认情况下，C类型以机器的本机格式和字节顺序表示，并在必要时通过跳过填充字节来正确对齐（根据C编译器使用的规则）</p>
<blockquote>
<p><strong>ustruct.calcsize(fmt)</strong></p>
</blockquote>
<p>返回存放 fmt 需要的字节数。</p>
<ul>
<li><code>fmt</code> ：格式字符的类型，详情见上文格化式字符表</li>
</ul>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ustruct
&gt;&gt;&gt; ustruct.calcsize('i')
4
&gt;&gt;&gt; ustruct.calcsize('f')
4
&gt;&gt;&gt; ustruct.calcsize('d')
8
</code></pre>
<blockquote>
<p><strong>ustruct.pack(fmt, v1, v2, ...)</strong></p>
</blockquote>
<p>按照格式字符串 fmt 压缩参数v1、 v2、…返回值是参数编码后的字节对象。</p>
<ul>
<li><code>fmt</code> ：格式字符的类型，详情见上文格化式字符表</li>
</ul>
<blockquote>
<p><strong>unstrcut.unpack(fmt, data)</strong></p>
</blockquote>
<p>根据格式化字符串 fmt 对数据进行解压，返回值为一个元组。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ustruct
&gt;&gt;&gt; ustruct.pack('ii', 7, 9)  #打包2两个整数
b'\x07\x00\x00\x00\t\x00\x00\x00'
&gt;&gt;&gt; ustruct.unpack('ii', b'\x07\x00\x00\x00\t\x00\x00\x00')  #解压两个整数
(7, 9)
</code></pre>
<blockquote>
<p><strong>ustruct.pack_info(fmt, buffer, offset, v1, v2, ...)</strong></p>
</blockquote>
<p>根据格式字符串fmt将值v1、v2、 …打包到从<code>offset</code>开始的缓冲区中。从缓冲区的末尾算起，<code>offset</code>可能为负。</p>
<ul>
<li><code>fmt</code> ：格式字符的类型，详情见上文格化式字符表</li>
</ul>
<blockquote>
<p><strong>unstruct.unpack_from(fmt, data, offset=0)</strong></p>
</blockquote>
<p>根据格式化字符串 <code>fmt</code> 解析从 <code>offest</code> 开始的数据解压，从缓冲区末尾开始计数的偏移量可能为负值。返回值是解压值的元组。</p>
<h4 id="ujson-json">ujson - JSON编码和解码</h4>
<p>ujson 模块实现在Python数据对象和JSON数据格式之间进行转换的功能。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/json.html#module-json">json</a></p>
<blockquote>
<p><strong>ujson.dump(obj, stream)</strong></p>
</blockquote>
<p>将 <code>obj</code> 数据对象转化成 JSON字符串，将其写入到给定的 <code>stream</code> 中。</p>
<blockquote>
<p><strong>ujson.dumps(dict)</strong></p>
</blockquote>
<p>将 <code>dict</code> 类型的数据转换成str。</p>
<blockquote>
<p><strong>ujson.load(stream)</strong></p>
</blockquote>
<p>解析给定的数据 <code>stream</code>，将其解释为JSON字符串并反序列化成Python对象。</p>
<blockquote>
<p><strong>ujson.loads(str)</strong></p>
</blockquote>
<p>解析JSON字符串并返回<code>obj</code>对象</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import ujson
&gt;&gt;&gt; msg = ['foo',{'bar':('baz',None,1,2)}]
&gt;&gt;&gt; print(msg)
['foo', {'bar': ('baz', None, 1, 2)}]
&gt;&gt;&gt; s = ujson.dumps(msg)
&gt;&gt;&gt; print(s)
[&quot;foo&quot;, {&quot;bar&quot;: [&quot;baz&quot;, null, 1, 2]}]
&gt;&gt;&gt; s1 = ujson.loads(s)
&gt;&gt;&gt; print(s1)
['foo', {'bar': ['baz', None, 1, 2]}]
</code></pre>
<h4 id="utime-">utime - 与时间相关功能</h4>
<p>utime 模块用于获取当前时间和日期、测量时间间隔和延迟。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/time.html#module-time">time</a></p>
<blockquote>
<p><strong>utime.localtime([secs])</strong></p>
</blockquote>
<p>该函数用来将一个以秒表示的时间转换为一个元组，元组包含了了年、月、日、时、分、秒、星期、一年中第几天；如果没有给定参数sec，则使用RTC时间。返回值形式如下：</p>
<p><code>(year, month, mday, hour, minute, second, weekday, yearday)</code></p>
<ul>
<li>
<p><code>year</code> ：年份，int型</p>
</li>
<li>
<p><code>month</code> ：月份，1~12，int型</p>
</li>
<li>
<p><code>mday</code> ：日，当月多少号，1~31，int型</p>
</li>
<li>
<p><code>hour</code> ：小时，0~23，int型</p>
</li>
<li>
<p><code>minute</code> ：分钟，0~59，int型</p>
</li>
<li>
<p><code>second</code> ：秒，0~59，int型</p>
</li>
<li>
<p><code>weekday</code> ：星期，周一到周日是0~6，int型</p>
</li>
<li>
<p><code>yearday</code> ：一年中的第多少天，int型</p>
</li>
</ul>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import utime
&gt;&gt;&gt; utime.localtime()
(2020, 9, 29, 8, 54, 42, 1, 273)
&gt;&gt;&gt; utime.localtime(646898736)
(2020, 7, 1, 6, 5, 36, 2, 183)
</code></pre>
<blockquote>
<p><strong>utime.mktime(date)</strong></p>
</blockquote>
<p>该函数作用与locatime()相反，它将一个存放在元组中的时间转换为以秒计的时间戳。</p>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; import utime
&gt;&gt;&gt; date = (2020, 9, 29, 8, 54, 42, 1, 273)
&gt;&gt;&gt; utime.mktime(date)
1601340882
</code></pre>
<blockquote>
<p><strong>utime.sleep(seconds)</strong></p>
</blockquote>
<p>休眠给定秒数的时间。</p>
<p>注意：sleep()函数的调用会导致程序休眠阻塞。</p>
<blockquote>
<p><strong>utime.sleep_ms(ms)</strong></p>
</blockquote>
<p>休眠给定毫秒数的时间。</p>
<p>注意：sleep_ms()函数的调用会导致程序休眠阻塞。</p>
<blockquote>
<p><strong>utime.sleep_us(us)</strong></p>
</blockquote>
<p>休眠给定微秒的时间。</p>
<p>注意：sleep_us()函数的调用会导致程序休眠阻塞。</p>
<blockquote>
<p><strong>utime.ticks_ms()</strong>  </p>
</blockquote>
<p>返回不断递增的毫秒计数器，在某些值后会重新计数(未指定)。计数值本身无特定意义，只适合用在 <code>ticks_diff()</code>函数中。</p>
<p>注意：sleep_us()函数的调用会导致程序休眠阻塞。</p>
<blockquote>
<p><strong>utime.ticks_us()</strong>  </p>
</blockquote>
<p>和<code>ticks_ms()</code>类似，只是返回微秒计数器。</p>
<blockquote>
<p><strong>utime.ticks_cpu()</strong> </p>
</blockquote>
<p>和 ticks_ms/ticks_us 类似，具有更高精度 (使用 CPU 时钟)。</p>
<blockquote>
<p><strong>utime.ticks_diff(old, new)</strong></p>
</blockquote>
<p>计算两次调用<code>ticks_ms()</code>， <code>ticks_us()</code>，或 <code>ticks_cpu()</code>之间的时间。因为这些函数的计数值可能会回绕，所以不能直接相减，需要使用 ticks_diff() 函数。“旧” 时间需要在 “新” 时间之前，否则结果无法确定。这个函数不要用在计算很长的时间 (因为 ticks_*() 函数会回绕，通常周期不是很长)。通常用法是在带超时的轮询事件中调用。</p>
<p>示例：</p>
<pre><code>import utime
start = utime.ticks_us()
while pin.value() == 0:
    if utime.ticks_diff(time.ticks_us(), start) &gt; 500:
        raise TimeoutError
</code></pre>
<blockquote>
<p><strong>utime.time()</strong>  </p>
</blockquote>
<p>返回自纪元以来的秒数（以整数形式）。如果未设置RTC，则此函数返回自特定于端口的参考时间点以来的秒数（对于不具有电池后备RTC的嵌入式板，通常是由于加电或复位）。如果要开发可移植的MicroPython应用程序，则不应依赖此功能提供高于秒的精度。如果需要更高的精度，请使用 <code>ticks_ms()</code>和<code>ticks_us()</code>函数，如果需要日历时间，则 <code>localtime()</code>不带参数会更好。</p>
<h4 id="sys-">sys - 系统相关功能</h4>
<p>sys 模块中提供了与QuecPython运行环境有关的函数和变量。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/sys.html#module-sys">sys</a></p>
<p><strong>常数说明</strong></p>
<blockquote>
<p><strong>sys.argv</strong></p>
</blockquote>
<p>当前程序启动的可变参数列表。</p>
<blockquote>
<p><strong>sys.byteorder</strong></p>
</blockquote>
<p>字节顺序 (‘little’  - 小端， ‘big’ - 大端)。</p>
<blockquote>
<p><strong>sys.implementation</strong></p>
</blockquote>
<p>返回当前microPython版本信息。对于MicroPython，它具有以下属性：</p>
<ul>
<li>name - 字符串“ micropython”</li>
<li>version - 元组（主要，次要，微型），例如（1、7、0）</li>
</ul>
<p>建议使用此对象来将MicroPython与其他Python实现区分开。</p>
<blockquote>
<p><strong>sys.maxsize</strong></p>
</blockquote>
<p>本机整数类型可以在当前平台上保留的最大值，如果它小于平台最大值，则为MicroPython整数类型表示的最大值（对于不支持长整型的MicroPython端口就是这种情况）。</p>
<blockquote>
<p><strong>sys.modules</strong></p>
</blockquote>
<p>已载入模块的字典。</p>
<blockquote>
<p><strong>sys.platform</strong></p>
</blockquote>
<p>MicroPython运行的平台。</p>
<blockquote>
<p><strong>sys.stdin</strong></p>
</blockquote>
<p>标准输入（默认是USB虚拟串口，可选其他串口）。</p>
<blockquote>
<p><strong>sys.stdout</strong></p>
</blockquote>
<p>标准输出（默认是USB虚拟串口，可选其他串口）。</p>
<blockquote>
<p><strong>sys.version</strong></p>
</blockquote>
<p>MicroPython 语言版本，字符串格式。</p>
<blockquote>
<p><strong>sys.version_info</strong></p>
</blockquote>
<p>MicroPython  语言版本，整数元组格式。</p>
<p><strong>方法</strong></p>
<blockquote>
<p><strong>sys.exit(retval=0)</strong></p>
</blockquote>
<p>使用给定的参数退出当前程序。与此同时，该函数会引发<code>SystemExit</code>退出。如果给定了参数，则将其值作为参数赋值给<code>SystemExit</code>。</p>
<blockquote>
<p><strong>sys.print_exception(exc, file=sys.stdout)</strong></p>
</blockquote>
<p>打印异常到文件对象，默认是 sys.stdout，即输出异常信息的标准输出。</p>
<h4 id="uzlib-zlib">uzlib - zlib解压缩</h4>
<p>uzlib 模块解压缩用<a href="https://en.wikipedia.org/wiki/DEFLATE">DEFLATE算法</a>压缩的二进制数据 （通常在zlib库和gzip存档器中使用），压缩尚未实现。该模块实现相应CPython模块的子集。更多信息请参阅阅CPython文档：<a href="https://docs.python.org/3.5/library/zlib.html#module-zlib">zlib</a></p>
<p>注意：解压缩前，应检查模块内可使用的空间，确保有足够空间解压文件。</p>
<blockquote>
<p><strong>uzlib.decompress(data, wbits=0, bufsize=0)</strong></p>
</blockquote>
<p>返回解压后的 bytes 对象。<code>wbits</code>是解压时使用的DEFLATE字典窗口大小（8-15，字典大小是<code>wbits</code>值的2的幂）。如果该值为正，则假定<code>data</code>为zlib流（带有zlib标头），如果为负，则假定为原始的DEFLATE流。<code>bufsize</code>参数是为了与CPython兼容，将被忽略。</p>
<blockquote>
<p><strong>class uzlib.DecompIO(stream, wbits=0)</strong></p>
</blockquote>
<p>创建一个<code>stream</code>装饰器，该装饰器允许在另一个流中透明地压缩数据。这允许处理数据大于可用堆大小的压缩流。wbits的值除了上面所述的值以外，还可以取值24..31（16 + 8..15），这表示输入流具有gzip标头。</p>
<h4 id="_thread-">_thread - 多线程</h4>
<p>_thread 模块提供创建新线程的方法，并提供互斥锁。</p>
<blockquote>
<p><strong>_thread.get_ident()</strong></p>
</blockquote>
<p>获取当前线程号。</p>
<blockquote>
<p><strong>_thread.get_heap_size()</strong></p>
</blockquote>
<p>获取系统剩余内存大小。</p>
<blockquote>
<p><strong>_thread.stack_size(size)</strong></p>
</blockquote>
<p>设置创建新线程使用的栈大小（以字节为单位），默认为8k。</p>
<blockquote>
<p><strong>_thread.start_new_thread(function, args)</strong></p>
</blockquote>
<p>创建一个新线程，接收执行函数和被执行函数参数。</p>
<blockquote>
<p><strong>_thread.allocate_lock()</strong></p>
</blockquote>
<p>创建一个互斥锁对象。</p>
<p>示例：</p>
<pre><code>import _thread
lock = _thread.allocate_lock()
</code></pre>
<blockquote>
<p><strong>lock.acquire()</strong></p>
</blockquote>
<p>获取锁，成功返回True，否则返回False。</p>
<blockquote>
<p><strong>lock.release()</strong></p>
</blockquote>
<p>释放锁。</p>
<blockquote>
<p><strong>lock.locked()</strong></p>
</blockquote>
<p>返回锁的状态，True表示被某个线程获取，False则表示没有。</p>
<p><strong>_thread使用示例</strong></p>
<pre><code>import _thread
a = 0
lock = _thread.allocate_lock()
def th_func(delay, id):
    global a
    while True:
        lock.acquire()  # 获取锁
        if a &gt;= 10:
            print('thread %d exit' % id)
            lock.release() # 释放锁
            break
        a+=1
        print('[thread %d] a is %d' % (id, a))
        lock.release()
for i in range(2):
    _thread.start_new_thread(th_func, (i + 1, i))

</code></pre>
<h4 id="uhashlib-">uhashlib - 哈希算法</h4>
<p>模块功能: 实现二进制数据散列算法,目前支持sha256，sha1，MD5。</p>
<blockquote>
<p>​ <strong>hash_obj = uhashlib.sha256(bytes)</strong></p>
</blockquote>
<p>创建一个SHA256哈希对象</p>
<ul>
<li>参数 </li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td>bytes</td>
<td>可选参数，可在创建时传入bytes数据，也可通过update方法</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>SHA256哈希对象</p>
<blockquote>
<p>​ <strong>hash_obj  = uhashlib.sha1(bytes)</strong></p>
</blockquote>
<p>创建一个SHA1哈希对象</p>
<ul>
<li>参数 </li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td>bytes</td>
<td>可选参数，可在创建时传入bytes数据，也可通过update方法</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>SHA1哈希对象</p>
<blockquote>
<p>​ <strong>hash_obj  = uhashlib.md5(bytes)</strong></p>
</blockquote>
<p>创建一个MD5哈希对象</p>
<ul>
<li>参数 </li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td>bytes</td>
<td>可选参数，可在创建时传入bytes数据，也可通过update方法</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>MD5哈希对象</p>
<p><strong>哈希对象方法</strong></p>
<blockquote>
<p>​ <strong>hash_obj .update(bytes)</strong></p>
</blockquote>
<p>将更多的bytes数据加到散列</p>
<ul>
<li>参数 </li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes</td>
<td>bytes</td>
<td>需要被加密的数据</td>
</tr>
</tbody>
</table>
<ul>
<li>返回值</li>
</ul>
<p>无</p>
<blockquote>
<p>​ <strong>hash_obj .digest()</strong></p>
</blockquote>
<p>返回通过哈希传递的所有数据的散列，数据为字节类型。调用此方法后，无法再将更多的数据送入散列。</p>
<ul>
<li>参数 </li>
</ul>
<p>无</p>
<ul>
<li>返回值</li>
</ul>
<p>返回加密后字节类型的数据</p>
<p><strong>使用实例</strong></p>
<pre><code class="language-python">import uhashlib
import ubinascii

hash_obj  = uhashlib.sha256()  # 创建hash对象
hash_obj.update(b&quot;QuecPython&quot;)
res = hash_obj.digest()
# b&quot;\x1e\xc6gq\xb3\xa9\xac&gt;\xa4\xc4O\x00\x9eTW\x97\xd4.\x9e}Bo\xff\x82u\x89Th\xfe'\xc6\xcd&quot;
# 转成十六进制表示
hex_msg = ubinascii.hexlify(res)
# b'1ec66771b3a9ac3ea4c44f009e545797d42e9e7d426fff8275895468fe27c6cd'
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../QuecPython%E5%B9%B3%E5%8F%B0%E6%80%A7%E6%8E%A5%E5%8F%A3/" class="btn btn-neutral float-right" title="QuecPython平台性接口">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../QuecPython%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="btn btn-neutral" title="QuecPython快速入门"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../QuecPython%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../QuecPython%E5%B9%B3%E5%8F%B0%E6%80%A7%E6%8E%A5%E5%8F%A3/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
